데이터 접근 기술에 대해서 더 알아보기 전에 데이터베이스에 연동하는 테스트에 대해서 알아보자.
데이터 접근 기술은 실제 데이터베이스에 접근해서 데이터를 잘 저장하고 조회할 수 있는지 확인하는 것이 필요하다. 지금부터 테스트를 실행할 때 실제 데이터베이스를 연동해서 진행해보자.

`ItemRepositoryTest`를 통해서 테스트를 진행할 것이다.

테스트를 실행하기 전에 먼저 지금까지 설정한 `application.properties`를 확인해보자.

**main - application.properties**
```
spring.profiles.active=local  
spring.datasource.url=jdbc:h2:tcp://localhost/~/test  
spring.datasource.username=sa  
spring.datasource.password=test  
logging.level.org.springframework.jdbc=debug
```

**test - application.properties**
```
spring.profiles.active=test
```

테스트 케이스는 `src/test`에 있기 때문에, 실행하면 `src/test`에 있는 `application.properties` 파일이 우선순위를 가지고 실행된다.
그런데 문제는 테스트용 설정에는 `spring.datasource.url`과 같은 데이터베이스 연결 설정이 없다는 점이다.
테스트 케이스에서도 데이터베이스에 접속할 수 있게 test의 `application.properties`를 다음과 같이 수정하자.

**test - application.properties 수정**
```
spring.profiles.active=test  
spring.datasource.url=jdbc:h2:tcp://localhost/~/test  
spring.datasource.username=sa  
spring.datasource.password=test  
logging.level.org.springframework.jdbc=debug
```


## 테스트 실행 - 로컬 DB
`ItemRepositoryTest` 테스트 코드를 확인해보자.
```java
@SpringBootTest
class ItemRepositoryTest {}
```
- `ItemRepositoryTest`는 `@SpringBootTest`를 사용한다. `@SpringBootTest`는 `@SpringBootApplication`를 찾아서 설정으로 사용한다.


```java
//@Import(MemoryConfig.class)  
//@Import(JdbcTemplateV1Config.class)  
//@Import(JdbcTemplateV2Config.class)  
@Import(JdbcTemplateV3Config.class)  
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")  
public class ItemServiceApplication {}
```

- `@SpringBootApplication` 설정이 과거에는 `MemoryConfig.class`를 사용하다가 이제는 `JdbcTemplateV3Config.class`를 사용하도록 변경되었다.
- 따라서 테스트도 `JdbcTemplate`을 통해 실제 데이터베이스를 호출하게 된다.  
- `MemoryItemRepository` -> `JdbcTemplateItemRepositoryV3`

**테스트 실행**
`ItemRepositoryTest` 테스트 전체를 실행하자.

**주의!** H2 데이터베이스 서버가 실행되어 있어야 한다.

**실행 결과**  
- `updateitem()` : 성공
- `save()` : 성공
- `findItems()` : **실패**

`findItems()`는 다음과 같은 오류를 내면서 실패했다.

```
java.lang.AssertionError: 
Expecting actual:
  [Item(id=1, itemName=itemA, price=10000, quantity=10),
    Item(id=2, itemName=itemB, price=20000, quantity=20),
    Item(id=3, itemName=itemA, price=10000, quantity=10),
...
```
`findItems()` 코드를 확인해보면 상품을 3개 저장하고, 조회한다.

```java
@Test  
void findItems() {  
    //given  
    Item item1 = new Item("itemA-1", 10000, 10);  
    Item item2 = new Item("itemA-2", 20000, 20);  
    Item item3 = new Item("itemB-1", 30000, 30);  
  
    itemRepository.save(item1);  
    itemRepository.save(item2);  
    itemRepository.save(item3);  
  
    // 여기서 3개 이상이 조회되는 문제가 발생
    // 기대로는 item1, item2, item3만 조회되어야 함.
    test(null, null, item1, item2, item3);  
    ...
}
```

결과적으로 테스트에서 저정한 3개의 데이터가 조회 되어야 하는데, 기대보다 더 많은 데이터가 조회되었다.

**실패 원인**
왜 이런 문제가 발생하는 것일까?
혹시 테스트를 실행할 때 `TestDataInit`이 실행되는 것은 아닐까? 이 문제는 아니다. `TestDataInit`은 프로필이 `local`일때만 동작하는데, 테스트 케이스를 실행할 때는 프로필이 `spring.profiles.active=test`이기 때문에 초기화 데이터가 추가되지는 않는다.

문제는 H2 데이터베이스에 이미 과거에 서버를 실행하면서 저장했던 데이터가 보관되어 있기 때문이다.
이 데이터가 현재 테스트에 영향을 준다. H2 데이터베이스 콘솔을 열어서 데이터를 확인해보자.

**H2 데이터베이스 데이터 확인**
- http://localhost:8082
- `SELECT * FROM ITEM` 을 실행하면 이미 서버를 실행해서 확인 할 때의 데이터가 저장되어 있는 것을 확인할 수 있다.


__출처: 인프런 김영한 지식공유자님의 강의 - 스프링 DB 2편__