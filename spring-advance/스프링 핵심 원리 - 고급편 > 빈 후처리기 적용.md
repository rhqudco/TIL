# 스프링 핵심 원리 - 고급편 > 빈 후처리기 적용
빈 후처리기를 사용해서 실제 객체 대신 프록시를 스프링 빈으로 등록하자.
이렇게 하면 수동은 물론, 컴포넌트 스캔을 사용하는 빈까지 모두 프록시를 적용할 수 있다.
더 나아가서 설정 파일에 있는 수 많은 프록시 생성 코드도 한번에 제거할 수 있다.

<img width="770" alt="image" src="https://github.com/user-attachments/assets/e8f71c20-6894-425e-8803-66adea4317f9">

```java
@Slf4j
public class PackageLogTracePostProcessor implements BeanPostProcessor {
  private final String basePackage;
  private final Advisor advisor;

  public PackageLogTracePostProcessor(String basePackage, Advisor advisor) {
    this.basePackage = basePackage;
    this.advisor = advisor;
  }

  @Override
  public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    log.info("param Bean Name = {}, Bean = {}", beanName, bean.getClass());

    // 프록시 적용 대상 여부 체크
    // 프록시 적용 대상이 아니면 원본을 그대로 반환
    String packageName = bean.getClass().getPackageName();
    if(!packageName.startsWith(basePackage)) {
      return bean;
    }

    // 프록시 대상이면 프록시를 만들어서 반환
    ProxyFactory proxyFactory = new ProxyFactory(bean);
    proxyFactory.addAdvisor(advisor);
    Object proxy = proxyFactory.getProxy();
    log.info("create proxy: target = {}, proxy = {}", bean.getClass(), proxy.getClass());
    return proxy;
  }
}
```

- `PackageLogTraceProxyPostProcessor`
  - 원본 객체를 프록시 객체로 변환하는 역할
  - 프록시 객체로 변환 시 프록시 팩토리를 사용
  - 프록시 팩토리는 advisor가 필요하기 때문에 외부에서 생성자를 통해 주입
- 모든 스프링 빈들에 프록시를 적용할 필요는 없고, 특정 패키지와 그 하위에 위치한 스프링 빈들만 프록시를 적용
  - 여기서는 `hello.proxy.app`과 관련된 부분에만 적용
  - 다른 패키지의 객체는 원본 그대로 사용
- 프록시 적용 대상의 반환 값을 보면 원본 객체 대신 프록시 객체를 반환
  - 따라서 스프링 컨테이너에 원복 객체 대신 프록시 객체가 스프링 빈으로 등록
  - 원본 객체는 스프링 빈으로 등록되지 않음

```java
@Slf4j
@Configuration
@Import({AppConfigV1.class, AppConfigV2.class})
public class BeanPostProcessorConfig {

  @Bean
  public PackageLogTracePostProcessor logTracePostProcessor(LogTrace logTrace) {
    return new PackageLogTracePostProcessor("hello.proxy.app", getAdvisor(logTrace));
  }

  private Advisor getAdvisor(LogTrace logTrace) {
    //pointcut
    NameMatchMethodPointcut pointcut = new NameMatchMethodPointcut();
    pointcut.setMappedNames("request*", "order*", "save*");
    //advice
    LogTraceAdvice advice = new LogTraceAdvice(logTrace);
    //advisor = pointcut + advice
    return new DefaultPointcutAdvisor(pointcut, advice);
  }
}
```
- `@Import({AppV1Config.class, AppV2Config.class})`
  - V3는 컴포넌트 스캔으로 자동으로 스프링 빈으로 등록되지만, V1, V2 애플리케이션은 수동으로 스프링 빈으로 등록해야 동작
  - `ProxyApplication`에서 등록해도 되지만 편의상 여기에 등록
- `@Bean logTraceProxyPostProcessor()`
  - 특정 패키지를 기준으로 프록시를 생성하는 빈 후처리기를 스프링 빈으로 등록
  - 빈 후처리기는 스프링 빈으로만 등록하면 자동으로 동작
  - 여기에 프록시를 적용할 패키지 정보(`hello.proxy.app`)와 어드바이저(`getAdvisor(logTrace)`)를 넘겨준다.
- 이제 **프록시를 생성하는 코드가 설정 파일에는 필요 없다.** 
  - 순수한 빈 등록만 고민하면 된다. 
  - 프록시를 생성하고 프록시를 스프링 빈으로 등록하는 것은 빈 후처리기가 모두 처리해준다.

```java
@Import(BeanPostProcessorConfig.class)
@SpringBootApplication(scanBasePackages = "hello.proxy.app") //주의
public class ProxyApplication {

	public static void main(String[] args) {
		SpringApplication.run(ProxyApplication.class, args);
	}

	@Bean
	public LogTrace logTrace() {
		return new ThreadLocalLogTrace();
	}

}
```

설정을 등록하고 실행하면 로그가 쭉~ 뜰텐데
중요한 부분만 남기고 하나씩 살펴보자.
실행 로그에 `create proxy`를 검색으로 검색하면 V1 ~ V3까지 프록시가 생성된 로그를 확인할 수 있다.

- **V1:** 인터페이스가 있으므로 JDK 동적 프록시가 적용된다.
- **V2:** 구체 클래스만 있으므로 CGLIB 프록시가 적용된다.
- **V3:** 구체 클래스만 있으므로 CGLIB 프록시가 적용된다.

**컴포넌트 스캔에도 적용**
여기서 중요한 포인트는 빈 후처리기 덕분에 v1, v2와 같이 수동으로 등록한 빈 뿐만 아니라 컴포넌트 스캔을 통해 등록한 v3 빈들도 프록시를 적용할 수 있다는 점이다.

**실행**
- http://localhost:8080/v1/request?itemId=hello
- http://localhost:8080/v2/request?itemId=hello
- http://localhost:8080/v3/request?itemId=hello

각 링크를 들어가서 로그를 보면 다 적용된 것을 알 수 있다.

**프록시 적용 대상 여부 체크**
애플리케이션을 실행해서 로그를 확인해보면 알겠지만, 우리가 직접 등록한 스프링 빈들 뿐만 아니라 스프링 부트가 기본으로 등록하는 수 많은 빈들이 빈 후처리기에 넘어온다.
그래서 어떤 빈을 프록시로 만들 것인지 기준이 필요하다.
여기서는 간단히 `basePackage` 를 사용해서 특정 패키지를 기준으로 해당 패키지와 그 하위 패키지의 빈들을 프록시로 만든다.
스프링 부트가 기본으로 제공하는 빈 중에는 프록시 객체를 만들 수 없는 빈들도 있다. 따라서 모든 객체를 프록시 로만들 경우 오류가 발생한다.


__출처: 김영한 지식공유자의 스프링 핵심 원리 고급편__