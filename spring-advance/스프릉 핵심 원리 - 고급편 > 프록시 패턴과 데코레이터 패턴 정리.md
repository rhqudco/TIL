# 스프링 고급편 - 프록시 패턴과 데코레이터 패턴 정리

GOF 데코레이터 패턴

<img width="937" alt="image" src="https://github.com/user-attachments/assets/ef09e0a6-96e0-4e95-b038-93ad5c06dc79">

이전 코드들을 보면 `Decorator`에 중복이 있다.
꾸며주는 역할을 하는 Decorator들은 스스로 존재할 수 없다.(MessageDecorator, TimeDecorator) 따라서 내부에 호출 대상인 Component를 항상 가지고 있어야 하며, 호출해주어야 한다.
이런 부분이 중복인데, 이런 중복을 제거하기 위해 Component를 속성으로 가지는 Decorator라는 추상 클래스를 만드는 방법도 고민의 여지가 있다.
추상 클래스를 추가하면 클래스 다이어그램을 통해 어떤 깃이 실제 컴포넌트로 사용되는지, 데코레이터인지도 구분할 수 있게 된다.
위 그램에서 `Decorator`라는 클래스가 `Component`를 속성으로 가지고 있다.

## 프록시 패턴 vs 데코레이터 패턴
프록시 패턴과 데코레이터 패턴은 모양이 거의 같고 상황에 따라 똑같을 경우도 있다.
둘의 구분은 패턴의 모양이 아니라 의도(Intent)를 통해 할 수 있다.
- 프록시
  - 다른 개체에 대한 접근 제어를 위한 대리자 제공
- 데코레이터
  - 객체에 추가 책임(기능)을 동적으로 추가하고, 기능 확장을 위한 유연한 대안 제공

정리하면, 프록시를 사용하고 해당 프록시가 접근 제어가 목적이라면 프록시 패턴이고, 새로운 기능을 추가하는 것이 목적이라면 데코레이터 패턴이 된다.


__출처: 김영한 지식공유자의 스프링 핵심 원리 고급편__